import json
import os

import pytest
import yaml  
from deepdiff import DeepDiff
from syrupy.assertion import SnapshotAssertion

from dashboard_compiler.dashboard.config import Dashboard

# Remove import for compile_dashboard
from dashboard_compiler.dashboard.view import KbnDashboard
from dashboard_compiler.dashboard_compiler import compile

SCENARIOS_DIR = os.path.join(os.path.dirname(__file__), 'scenarios')

CONFIG_FILE = 'config.yaml'
KIBANA_EXPORT = 'from-kibana.json'

# Define scenarios to include (Markdown, Search, Links, Controls, Lens)
# Exclude Maps for now
INCLUDED_SCENARIOS = [
    # "1password-audit-events",  # Lens
    # "1password-item-usages",  # Lens
    # "1password-signin-attempts",  # Lens
    # "one-vertical-bar",  # Lens
    # "one-link",  # Links
    'controls',  # Controls
    'empty',  # Empty dashboard
    'one-filter',
    'one-link',
    'one-markdown',  # Markdown
    'one-pie-chart',  # Lens
    'one-query',
    'metrics/one-metrics-primary-unique-count',  # Metrics chart scenario
    # Add new XY chart scenarios
    # "table/one-table-two-rows-one-metric",
    'table/one-table-two-rows-split-metric-sorted-width',
    'xy/one-area-percent-timestamp-two-series',
    'xy/one-area-stacked-timestamp-two-series',
    'xy/one-area-unstacked-timestamp-two-series',
    'xy/one-horizontal-bar-unstacked-timestamp-two-series',
    'xy/one-line-unstacked-timestamp-two-series',
    'xy/one-vertical-bar-unstacked-timestamp-breakdown',
    # Add ESQL scenarios
    'to-do/esql/one-esql-line-chart',
    'to-do/esql/one-esql-pie-chart',
    'to-do/esql/one-esql-table',
]

# EXCLUDE_PATHS for DeepDiff might need adjustment based on the final view model structure
EXCLUDE_PATHS = [
    "root['created_by']",
    "root['updated_at']",
    "root['created_at']",
    "root['references'][0]['id']",
    "root['id']",
    "root['version']",
    "root['updated_by']",
    "root['attributes']['optionsJSON']['syncColors']",
    "root['attributes']['optionsJSON']['syncTooltips']",
    "root['attributes']['version']",
]

EXCLUDE_PATHS_REGEX = []  # [r".*\['id'\]", r".*\['i'\]", r".*\['panelIndex'\]"]


@pytest.fixture(params=INCLUDED_SCENARIOS)
def load_scenario(request):
    scenario = request.param

    scenario_dir = os.path.join(SCENARIOS_DIR, scenario)

    dashboard_yaml_path = os.path.join(scenario_dir, CONFIG_FILE)

    kibana_ref_path = os.path.join(scenario_dir, KIBANA_EXPORT)

    # Load the config YAML and parse into config models
    with open(dashboard_yaml_path) as f:
        dashboard_dict = yaml.safe_load(f)

    with open(kibana_ref_path) as f:
        kibana_ref_dict = json.load(f)

    kibana_ref_dict = expand_dashboard_json(kibana_ref_dict)

    return (scenario, dashboard_dict, kibana_ref_dict)


async def test_dashboard_compilation(load_scenario, snapshot_json: SnapshotAssertion):
    """Tests compiling a dashboard configuration and compares the output to a snapshot."""
    scenario, dashboard_dict, kibana_ref_dict = load_scenario

    dashboard = Dashboard(**dashboard_dict['dashboard'])

    # compile the dashboard!
    view_dashboard: KbnDashboard = compile(dashboard)
    view_dashboard_dict = view_dashboard.model_dump(serialize_as_any=True, exclude_none=True)
    view_dashboard_dict = expand_dashboard_json(view_dashboard_dict)

    # Fail on unexpected changes to our rendered dashboard
    assert view_dashboard_dict == snapshot_json

    # Compare the generated JSON (as dict) with the loaded reference dashboard (as dict) using DeepDiff
    # Exclude dynamic fields like IDs and timestamps
    diff = DeepDiff(
        t1=kibana_ref_dict,
        t2=view_dashboard_dict,
        exclude_paths=EXCLUDE_PATHS,
        exclude_regex_paths=EXCLUDE_PATHS_REGEX,
        ignore_order=True,
        threshold_to_diff_deeper=0,
        verbose_level=2,
    )

    # Snapshot the diff to track discrepancies (which should ideally be empty or minimal)
    # This is our "to-do" list basically
    assert diff == snapshot_json(name='diff')


def expand_dashboard_json(dashboard_dict: dict) -> dict:
    """Expand the dashboard JSON to include all nested structures.
    This is useful for debugging and ensuring all parts of the dashboard are included.
    """
    # Sometimes panelsJSON is a stringified blob in the reference
    if isinstance(dashboard_dict.get('attributes', {}).get('panelsJSON'), str):
        dashboard_dict['attributes']['panelsJSON'] = json.loads(dashboard_dict['attributes']['panelsJSON'])

    # Sometimes optionsJSON is a stringified blob in the reference
    if isinstance(dashboard_dict.get('attributes', {}).get('optionsJSON'), str):
        dashboard_dict['attributes']['optionsJSON'] = json.loads(dashboard_dict['attributes']['optionsJSON'])

    # Also load panelsJSON from controlGroupInput if present (for Controls)
    if isinstance(dashboard_dict.get('attributes', {}).get('controlGroupInput', {}).get('panelsJSON'), str):
        dashboard_dict['attributes']['controlGroupInput']['panelsJSON'] = json.loads(
            dashboard_dict['attributes']['controlGroupInput']['panelsJSON'],
        )

    # Also load searchSourceJSON from kibanaSavedObjectMeta if present (for searches and filters)
    if isinstance(dashboard_dict.get('attributes', {}).get('kibanaSavedObjectMeta', {}).get('searchSourceJSON'), str):
        dashboard_dict['attributes']['kibanaSavedObjectMeta']['searchSourceJSON'] = json.loads(
            dashboard_dict['attributes']['kibanaSavedObjectMeta']['searchSourceJSON'],
        )

    return dashboard_dict


def json_to_so_import(dashboard_dict: dict) -> str:
    """Convert the dashboard dictionary to a JSON string suitable for Kibana import.
    This is useful for debugging and ensuring the output matches expected formats.
    """
    # This must be a single line of JSON for Kibana import
    unpretty = json.dumps(
        dashboard_dict,
        indent=None,
    )

    return unpretty
