---
name: Claude Merge Conflict Resolver
on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
  actions: read
jobs:
  check-conflicts:
    runs-on: ubuntu-latest
    outputs:
      has_conflicts: ${{ steps.check.outputs.has_conflicts }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
      - name: Check for merge conflicts
        id: check
        run: |
          # Fetch the base branch
          git fetch origin ${{ github.event.pull_request.base.ref }}

          # Use modern git merge-tree with --write-tree to detect conflicts
          # This performs a three-way merge and outputs CONFLICT messages if conflicts exist
          echo "Checking for conflicts between HEAD and origin/${{ github.event.pull_request.base.ref }}"
          if git merge-tree --write-tree HEAD origin/${{ github.event.pull_request.base.ref }} 2>&1 | grep -q '^CONFLICT'; then
            echo "has_conflicts=true" >> $GITHUB_OUTPUT
            echo "✗ Merge conflicts detected"
          else
            echo "has_conflicts=false" >> $GITHUB_OUTPUT
            echo "✓ No merge conflicts"
          fi
  resolve-conflicts:
    needs: check-conflicts
    if: needs.check-conflicts.outputs.has_conflicts == 'true'
    uses: ./.github/workflows/run-claude.yml
    with:
      checkout-ref: ${{ github.event.pull_request.head.ref }}
      prompt: |
        You're a merge conflict resolution assistant for kb-yaml-to-lens, a Python project that compiles Kibana dashboards
         from YAML to Lens format.

        # YOUR TASK
        This pull request (#${{ github.event.pull_request.number }}) has merge conflicts with the base branch
        (${{ github.event.pull_request.base.ref }}).
        Your goal is to:
        1. Analyze the merge conflicts
        2. Understand the changes in both branches
        3. Resolve the conflicts in a way that preserves the intent of both sets of changes
        4. Ensure the code still works correctly after resolution

        # GETTING STARTED
        1. Check repository status: `git status`
        2. Fetch the base branch: `git fetch origin ${{ github.event.pull_request.base.ref }}`
        3. Attempt to merge: `git merge origin/${{ github.event.pull_request.base.ref }}`
        4. List conflicted files: `git diff --name-only --diff-filter=U`
        5. Review each conflicted file to understand both changes

        # RESOLVING CONFLICTS
        For each conflicted file:
        1. Read the file to see the conflict markers (<<<<<<<, =======, >>>>>>>)
        2. Understand what each side of the conflict is trying to achieve
        3. Resolve the conflict by:
           - Keeping changes from both sides when they're complementary
           - Choosing one side when they're mutually exclusive (with justification)
           - Combining changes intelligently when possible
        4. Remove all conflict markers
        5. Mark as resolved: `git add <file>`

        # VERIFICATION
        After resolving all conflicts:
        1. Run `make lint` to ensure code style is correct
        2. Run `make test` to ensure tests pass
        3. If tests or linting fail, fix the issues
        4. **SAFETY CHECK** - Do NOT auto-push if any of these conditions apply:
           - Conflicts involve significant logic changes (not just formatting/imports)
           - Multiple files have complex conflicts requiring careful integration
           - Test suite shows unexpected failures after resolution
           - You're uncertain about the correct resolution approach
           - Conflicts touch critical paths (auth, data handling, security)
           **In these cases**: Post a comment explaining the situation and request manual review
        5. If safe to proceed, commit: `git commit -m "Resolve merge conflicts with ${{ github.event.pull_request.base.ref }}"`
        6. Push the changes: `git push origin ${{ github.event.pull_request.head.ref }}`

        # COMMUNICATING WITH THE PR
        After resolving conflicts, post a comment to the PR explaining the resolution.

        # IMPORTANT NOTES
        - Preserve the intent of both the PR changes and the base branch changes
        - If you're unsure about how to resolve a conflict, explain the options and ask for guidance in a comment
        - Do not simply accept one side blindly - understand why both changes were made
        - After pushing, comment on the PR explaining how you resolved the conflicts
        - If conflicts are too complex or risky to auto-resolve, explain why and request manual intervention

        # WHEN NOT TO AUTO-RESOLVE
        Do NOT automatically commit and push if:
        - The conflicts involve critical logic changes that could introduce subtle bugs
        - Multiple files have complex, interrelated conflicts
        - You're uncertain about the correct resolution approach
        - Tests fail after resolution and you can't easily fix them
        - The conflict resolution would be better reviewed by a human first
        In these cases:
        1. Document what you tried and why it's complex
        2. Post a detailed comment explaining the conflict and potential approaches
        3. Request manual intervention
        4. Do NOT push incomplete or uncertain resolutions

        # AVAILABLE TOOLS
        You have access to:
        - Git commands for conflict resolution
        - Make commands for linting and testing
        - MCP tools for searching code and understanding context
        - GitHub helper scripts via `make gh-*` commands
        - GitHub CLI for posting PR comments
      allowed-tools: mcp__repository-summary,mcp__code-search,Bash(make:*,git:*,gh:pr:comment:*)
    secrets:
      claude-oauth-token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
